alter session set "_ORACLE_SCRIPT"=true;
CREATE USER test identified by 111;
grant create session to test;
grant create table to test;
grant create procedure to test;
grant create trigger to test;
grant create view to test;
grant create sequence to test;
grant alter any table to test;
grant alter any procedure to test;
grant alter any trigger to test;
grant alter profile to test;
grant delete any table to test;
grant drop any table to test;
grant drop any procedure to test;
grant drop any trigger to test;
grant drop any view to test;
grant drop profile to test;

grant select on sys.v_$session to test;
grant select on sys.v_$sesstat to test;
grant select on sys.v_$statname to test;
grant SELECT ANY DICTIONARY to test;

---------------------1------------------
CREATE TABLE STUDENTS (
    ID NUMBER,
    NAME VARCHAR2(100),
    GROUP_ID NUMBER
);

CREATE TABLE GROUPS (
    ID NUMBER,
    NAME VARCHAR2(100),
    C_VAL NUMBER
);

DROP TABLE STUDENTS;
DROP TABLE GROUPS;

---------------------2------------------

CREATE OR REPLACE TRIGGER Students_UniqueID
BEFORE INSERT OR UPDATE ON STUDENTS
FOR EACH ROW
DECLARE
    id_count NUMBER;
BEGIN
    IF :NEW.ID IS NOT NULL THEN
        -- Проверяем, меняется ли значение идентификатора в новой записи
        IF INSERTING OR (:OLD.ID <> :NEW.ID) THEN
            SELECT COUNT(*) INTO id_count FROM STUDENTS WHERE ID = :NEW.ID;
            IF id_count > 0 THEN
                RAISE_APPLICATION_ERROR(-20001, 'Код студента должен быть уникальным.');
            END IF;
        END IF;
    END IF;
END;

CREATE OR REPLACE TRIGGER Students_AutoIncrement
BEFORE INSERT ON STUDENTS
FOR EACH ROW
BEGIN
    IF :NEW.ID IS NULL THEN
        SELECT NVL(MAX(ID), 0) + 1 INTO :NEW.ID FROM STUDENTS;
    END IF;
END;


CREATE OR REPLACE TRIGGER Groups_UniqueName
BEFORE INSERT OR UPDATE ON GROUPS
FOR EACH ROW
DECLARE
    name_count NUMBER;
BEGIN
    IF :NEW.NAME IS NOT NULL THEN
        -- Проверяем, меняется ли значение имени в новой записи
        IF INSERTING OR (:OLD.NAME <> :NEW.NAME) THEN
            SELECT COUNT(*) INTO name_count FROM GROUPS WHERE NAME = :NEW.NAME;
            IF name_count > 0 THEN
                RAISE_APPLICATION_ERROR(-20002, 'Название группы должно быть уникальным.');
            END IF;
        END IF;
    END IF;
END;


CREATE OR REPLACE TRIGGER Groups_UniqueID
BEFORE INSERT OR UPDATE ON GROUPS
FOR EACH ROW
DECLARE
    id_count NUMBER;
BEGIN
    IF :NEW.ID IS NOT NULL THEN
        -- Проверяем, меняется ли значение идентификатора в новой записи
        IF INSERTING OR (:OLD.ID <> :NEW.ID) THEN
            SELECT COUNT(*) INTO id_count FROM GROUPS WHERE ID = :NEW.ID;
            IF id_count > 0 THEN
                RAISE_APPLICATION_ERROR(-20002, 'Код группы должен быть уникальным.');
            END IF;
        END IF;
    END IF;
END;


CREATE OR REPLACE TRIGGER Groups_AutoIncrement
BEFORE INSERT ON GROUPS
FOR EACH ROW
BEGIN
    IF :NEW.ID IS NULL THEN
        SELECT NVL(MAX(ID), 0) + 1 INTO :NEW.ID FROM GROUPS;
    END IF;
END;

INSERT INTO STUDENTS (NAME, GROUP_ID) VALUES ('Иванов Иван', 4);
INSERT INTO STUDENTS (NAME, GROUP_ID) VALUES ('Петров Петр', 3);
INSERT INTO STUDENTS (NAME, GROUP_ID) VALUES ('Сидоров Сидор', 3);
INSERT INTO STUDENTS (NAME, GROUP_ID) VALUES ('Козлов Алексей', 4);

INSERT INTO GROUPS (ID, NAME, C_VAL) VALUES (4, 'Группа 1', 2);
INSERT INTO GROUPS (NAME, C_VAL) VALUES ('Группа 2', 2);
INSERT INTO GROUPS (ID, NAME, C_VAL) VALUES (3, 'Группа 3', 0);

---------------------3------------------

CREATE OR REPLACE TRIGGER Cascade_Delete_Students
BEFORE DELETE ON GROUPS
FOR EACH ROW
BEGIN
    DELETE FROM STUDENTS WHERE GROUP_ID = :OLD.ID;
    EXCEPTION
    WHEN OTHERS THEN
                NULL;
END;


SELECT * FROM GROUPS;
SELECT * FROM STUDENTS;
DELETE FROM GROUPS WHERE ID = 3;

---------------------4------------------

CREATE TABLE students_log (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY,
    username VARCHAR2(100) NOT NULL,
    date_of_action DATE NOT NULL,
    operation VARCHAR2(10) NOT NULL,
    stud_id NUMBER NOT NULL,
    stud_name VARCHAR2(100) NOT NULL,
    stud_group_id NUMBER NOT NULL
);

CREATE OR REPLACE TRIGGER Students_Logging
AFTER INSERT OR UPDATE OR DELETE ON STUDENTS
FOR EACH ROW
DECLARE
    v_username VARCHAR2(30) := USER;
    v_date DATE := SYSDATE;
    v_operation VARCHAR2(20);
BEGIN
    IF INSERTING THEN
        v_operation := 'INSERT';
        INSERT INTO STUDENTS_LOG (USERNAME, DATE_OF_ACTION, OPERATION, STUD_ID, STUD_NAME, STUD_GROUP_ID)
        VALUES (v_username, v_date, v_operation, :NEW.ID, :NEW.NAME, :NEW.GROUP_ID);
    ELSIF UPDATING THEN
        v_operation := 'UPDATE';
        INSERT INTO STUDENTS_LOG (USERNAME, DATE_OF_ACTION, OPERATION, STUD_ID, STUD_NAME, STUD_GROUP_ID)
        VALUES (v_username, v_date, v_operation, :NEW.ID, :NEW.NAME, :NEW.GROUP_ID);
    ELSIF DELETING THEN
        v_operation := 'DELETE';
        INSERT INTO STUDENTS_LOG (USERNAME, DATE_OF_ACTION, OPERATION, STUD_ID, STUD_NAME, STUD_GROUP_ID)
        VALUES (v_username, v_date, v_operation, :OLD.ID, :OLD.NAME, :OLD.GROUP_ID);
    END IF;
END;


INSERT INTO STUDENTS (NAME, GROUP_ID) VALUES ('Иванов Иван', 4);
INSERT INTO STUDENTS (NAME, GROUP_ID) VALUES ('Петров Петр', 3);
INSERT INTO STUDENTS (NAME, GROUP_ID) VALUES ('Сидоров Сидор', 3);
INSERT INTO STUDENTS (NAME, GROUP_ID) VALUES ('Козлов Алексей', 4);

INSERT INTO GROUPS (ID, NAME, C_VAL) VALUES (4, 'Группа 1', 2);
INSERT INTO GROUPS (NAME, C_VAL) VALUES ('Группа 2', 2);
INSERT INTO GROUPS (ID, NAME, C_VAL) VALUES (3, 'Группа 3', 0);

DELETE FROM GROUPS WHERE ID = 3;


SELECT * FROM students_log

---------------------5------------------

CREATE OR REPLACE PROCEDURE Restore_Students_Info_By_Date (date_time IN TIMESTAMP)
AS
    cur_date TIMESTAMP := SYSDATE;
BEGIN
    DELETE FROM students;
    DELETE FROM students_log WHERE date_of_action >= cur_date;
    
    FOR stud IN (SELECT * FROM students_log WHERE date_of_action <= date_time ORDER BY date_of_action ASC) LOOP
        IF stud.operation = 'INSERT' THEN
            INSERT INTO students (id, name, group_id) VALUES (stud.stud_id, stud.stud_name, stud.stud_group_id);
        ELSIF stud.operation = 'UPDATE' THEN
            UPDATE students SET group_id = stud.stud_group_id, name = stud.stud_name WHERE stud.stud_id = id;
        ELSIF stud.operation = 'DELETE' THEN
            DELETE FROM students WHERE stud.stud_id = id;
        END IF;
    END LOOP;

    DELETE FROM students_log WHERE date_of_action >= cur_date;
END;


CREATE OR REPLACE PROCEDURE Restore_Students_Info_By_Offset (date_time IN INTERVAL DAY TO SECOND)
AS
    cur_date TIMESTAMP := SYSDATE;
BEGIN
    DELETE FROM students;
    DELETE FROM students_log WHERE date_of_action >= cur_date;
    FOR stud IN (SELECT * FROM students_log WHERE date_of_action <= cur_date - date_time ORDER BY date_of_action ASC) LOOP
        IF stud.operation = 'INSERT' THEN
            INSERT INTO students (id, name, group_id) VALUES (stud.stud_id, stud.stud_name, stud.stud_group_id);
        ELSIF stud.operation = 'UPDATE' THEN
            UPDATE students SET group_id = stud.stud_group_id, name = stud.stud_name WHERE stud.stud_id = id;
        ELSIF stud.operation = 'DELETE' THEN
            DELETE FROM students WHERE stud.stud_id = id;
        END IF;
    END LOOP;

    DELETE FROM students_log WHERE date_of_action >= cur_date;
END;


CALL Restore_Students_Info_By_Date('05.03.2024 22:48:24');
CALL Restore_Students_Info_By_Offset('0 00:01:00')


INSERT INTO STUDENTS (NAME, GROUP_ID) VALUES ('Иванов Иван', 4);
INSERT INTO STUDENTS (NAME, GROUP_ID) VALUES ('Петров Петр', 3);
INSERT INTO STUDENTS (NAME, GROUP_ID) VALUES ('Сидоров Сидор', 3);
INSERT INTO STUDENTS (NAME, GROUP_ID) VALUES ('Козлов Алексей', 4);

DELETE FROM STUDENTS WHERE id = 22;

SELECT * FROM STUDENTS;
SELECT * FROM STUDENTS_LOG;

DELETE FROM STUDENTS_LOG;

ALTER SESSION SET NLS_DATE_FORMAT = 'DD-MM-YYYY HH24:MI:SS';

---------------------6------------------
CREATE OR REPLACE TRIGGER Group_C_Val_Students_Update
AFTER UPDATE ON STUDENTS
FOR EACH ROW
BEGIN
  IF (:OLD.GROUP_ID != :NEW.GROUP_ID) THEN
    UPDATE GROUPS SET c_val = c_val - 1 WHERE id = :OLD.GROUP_ID;
    UPDATE GROUPS SET c_val = c_val + 1 WHERE id = :NEW.GROUP_ID;
  END IF;
END;


CREATE OR REPLACE TRIGGER Group_C_Val_Students_Insert
AFTER INSERT ON STUDENTS
FOR EACH ROW
BEGIN
  UPDATE GROUPS SET c_val = c_val + 1 WHERE id = :NEW.GROUP_ID;
END;


CREATE OR REPLACE TRIGGER Group_C_Val_Students_Delete
BEFORE DELETE ON STUDENTS
FOR EACH ROW
DECLARE
    v_count NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count FROM groups WHERE id = :OLD.GROUP_ID;
    
    IF v_count > 0 THEN
       UPDATE GROUPS SET c_val = c_val - 1 WHERE id = :OLD.GROUP_ID;    
    END IF;
    
    EXCEPTION
    WHEN OTHERS THEN
                NULL;
END;

INSERT INTO STUDENTS (NAME, GROUP_ID) VALUES ('Евгений Ласевич', 1);
INSERT INTO STUDENTS (NAME, GROUP_ID) VALUES ('Максим Пухов', 1);
INSERT INTO STUDENTS (NAME, GROUP_ID) VALUES ('Валентин  Красовский', 1);
INSERT INTO STUDENTS (NAME, GROUP_ID) VALUES ('Игорь Шевеленков', 3);

